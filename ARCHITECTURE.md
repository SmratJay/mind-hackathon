# 4-Bit Processor Architecture Diagram

## Component Hierarchy (Bottom-Up)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     SIMPLE4_PROC (Top-Level)                 â”‚
â”‚                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚    PC    â”‚â”€â”€â”€â–¶â”‚ DECODER_FSM  â”‚â”€â”€â”€â–¶â”‚   RAM 16Ã—4    â”‚    â”‚
â”‚  â”‚ (4-bit)  â”‚    â”‚  (5 states)  â”‚    â”‚  (Sync)       â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                          â”‚                     â”‚            â”‚
â”‚                          â”‚ (control signals)   â”‚            â”‚
â”‚                          â–¼                     â–¼            â”‚
â”‚                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚                   â”‚   ALU_4B    â”‚â—€â”€â”€â”€â”€â”€â”‚  ALU_REG_4B â”‚    â”‚
â”‚                   â”‚  (Comb)     â”‚      â”‚  (Register) â”‚    â”‚
â”‚                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## FSM State Machine

```
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚   INIT   â”‚ (Reset State)
        â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
             â”‚
             â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”Œâ”€â”€â–¶â”‚  FETCH   â”‚ (Read instruction from RAM[PC])
    â”‚   â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  PC++
    â”‚        â”‚
    â”‚        â–¼
    â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚   â”‚   LOAD   â”‚ (Read operand from RAM[op1])
    â”‚   â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
    â”‚        â”‚
    â”‚        â–¼
    â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚   â”‚ EXECUTE  â”‚ (ALU performs operation)
    â”‚   â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
    â”‚        â”‚
    â”‚        â–¼
    â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â””â”€â”€â”€â”‚  STORE   â”‚ (Write result to RAM[op1])
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ALU Component Hierarchy (Structural Reuse)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      ALU_4B (Top)                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  Arithmetic Path (S[2]=0)                       â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚ â”‚
â”‚  â”‚  â”‚         ADDER_4B                     â”‚       â”‚ â”‚
â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”    â”‚       â”‚ â”‚
â”‚  â”‚  â”‚  â”‚FA0 â”‚â”€â”€â”‚FA1 â”‚â”€â”€â”‚FA2 â”‚â”€â”€â”‚FA3 â”‚    â”‚       â”‚ â”‚
â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”˜    â”‚       â”‚ â”‚
â”‚  â”‚  â”‚     â†‘       â†‘       â†‘       â†‘       â”‚       â”‚ â”‚
â”‚  â”‚  â”‚     â”‚       â”‚       â”‚       â”‚       â”‚       â”‚ â”‚
â”‚  â”‚  â”‚  Each FA_1B instantiates 2Ã— XOR_1B  â”‚       â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  Logic Path (S[2]=1)                            â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”â”‚ â”‚
â”‚  â”‚  â”‚XOR_1B  â”‚  â”‚XOR_1B  â”‚  â”‚XOR_1B  â”‚  â”‚XOR_1B  â”‚â”‚ â”‚
â”‚  â”‚  â”‚ [0]    â”‚  â”‚ [1]    â”‚  â”‚ [2]    â”‚  â”‚ [3]    â”‚â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚ â”‚
â”‚  â”‚  (Used for XOR operation, S=101)                â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Bottom Components:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   XOR_1B     â”‚ (Primitive: uses only ~, &, |)
â”‚  C = (A&~B)  â”‚
â”‚    | (~A&B)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â†‘
       â”‚ (instantiated by)
       â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    FA_1B     â”‚ (1-bit Full Adder)
â”‚  S = AâŠ•BâŠ•Cin â”‚ (uses 2Ã— XOR_1B)
â”‚  Cout = ...  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â†‘
       â”‚ (instantiated 4Ã— by)
       â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ADDER_4B    â”‚ (4-bit Ripple Carry Adder)
â”‚  Chains 4Ã—   â”‚ (No + operator!)
â”‚  FA_1B       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Instruction Format (11 bits)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  [10:8]  â”‚    [7:4]     â”‚    [3:0]     â”‚
â”‚  Opcode  â”‚  op1 (addr)  â”‚  op2 (data)  â”‚
â”‚  3 bits  â”‚   4 bits     â”‚   4 bits     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Opcode Table:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Binary â”‚ Mnemonic â”‚ Operation             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  000   â”‚   STO    â”‚ M[op1] â† op2          â”‚
â”‚  001   â”‚   ADD    â”‚ M[op1] â† M[op1] + op2 â”‚
â”‚  010   â”‚   SUB    â”‚ M[op1] â† M[op1] - op2 â”‚
â”‚  011   â”‚   AND    â”‚ M[op1] â† M[op1] & op2 â”‚
â”‚  100   â”‚   OR     â”‚ M[op1] â† M[op1] | op2 â”‚
â”‚  101   â”‚   XOR    â”‚ M[op1] â† M[op1] âŠ• op2 â”‚
â”‚  110   â”‚   NOT    â”‚ M[op1] â† ~M[op1]      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ALU Control Signal Mapping

```
S[2:0]  â”‚ Cin â”‚ Function     â”‚ Data Path Used      â”‚ Notes
â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 000    â”‚  0  â”‚ F = A        â”‚ ADDER (B=0, Cin=0) â”‚ Transfer
 001    â”‚  0  â”‚ F = A + B    â”‚ ADDER (B, Cin=0)   â”‚ Addition
 010    â”‚  1  â”‚ F = A - B    â”‚ ADDER (~B, Cin=1)  â”‚ Subtraction (2's comp)
 011    â”‚  X  â”‚ F = A & B    â”‚ Logic Gates         â”‚ AND
 100    â”‚  X  â”‚ F = A | B    â”‚ Logic Gates         â”‚ OR
 101    â”‚  X  â”‚ F = A âŠ• B    â”‚ 4Ã— XOR_1B          â”‚ XOR (custom gates!)
 110    â”‚  X  â”‚ F = ~A       â”‚ Logic Gates         â”‚ NOT
```

## Data Path Flow (Single Instruction Cycle)

```
Clock Cycle:  1         2         3         4         5
State:      FETCH     LOAD    EXECUTE    STORE    FETCH
            â”‚         â”‚         â”‚         â”‚         â”‚
            â–¼         â–¼         â–¼         â–¼         â–¼
RAM:     Read      Read      Idle      Write     Read
         [PC]      [op1]               [op1]     [PC]
         â”‚         â”‚                     â–²
         â”‚         â”‚                     â”‚
         â–¼         â–¼                     â”‚
      Instr    Data (A)                 â”‚
      Decode    â”‚                       â”‚
         â”‚      â–¼                       â”‚
         â”‚    ALU â—„â”€â”€ op2 (B)           â”‚
         â”‚      â”‚                       â”‚
         â”‚      â–¼                       â”‚
         â”‚   ALU_REG (1 cycle delay)   â”‚
         â”‚      â”‚                       â”‚
         â”‚      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â””â”€â”€â–º PC++
```

## Memory Map Example (After Test Program)

```
Address  â”‚ Initial â”‚ After Program â”‚ Notes
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
0x0      â”‚  0x0    â”‚  0x0          â”‚ (Program code area)
0x1      â”‚  0x0    â”‚  0x8          â”‚ 0xF - 0x7 = 0x8 âœ“
0x2      â”‚  0x0    â”‚  0x0          â”‚
0x3      â”‚  0x0    â”‚  0x0          â”‚
0x4      â”‚  0x0    â”‚  0xB          â”‚ 0x5 + 0x6 = 0xB âœ“
0x5      â”‚  0x0    â”‚  0x0          â”‚
...      â”‚  ...    â”‚  ...          â”‚
0xF      â”‚  0x0    â”‚  0xF          â”‚ ~0x0 = 0xF âœ“
```

## Critical Design Features

### 1. Asynchronous Reset Behavior
```verilog
always @(posedge clk or negedge reset_n) begin
    if (!reset_n)
        state = INIT;      // Immediate reset (blocking =)
    else
        state <= next_state; // Normal operation (non-blocking <=)
end
```

### 2. Tri-State Bus (Early Design, Async RAM)
```
RAM Output:  â”€â”€â”€â”€Zâ”€â”€â”€â”€Zâ”€â”€â”€â”€[DATA]â”€â”€â”€â”€Zâ”€â”€â”€â”€Zâ”€â”€â”€â”€
             ^    ^    ^      ^      ^    ^
             â”‚    â”‚    â”‚      â”‚      â”‚    â”‚
            Not  Write  â”‚    Read    â”‚   Not
           Selected      â”‚           â”‚  Selected
                     Transitioning  Valid
```

### 3. Pipeline Stage (ALU Register)
```
Timing:
EXECUTE state:  ALU computes result (combinational)
     â†“          Result not stable yet
    [Clock Edge]
     â†“          Result registered in ALU_REG_4B
STORE state:    Registered result written to RAM
                (This is why STORE comes after EXECUTE)
```

## Constraint Verification Summary

```
âœ… xor_1b.v       No ^ operator used
âœ… fa_1b.v        Instantiates 2Ã— xor_1b
âœ… adder_4b.v     Instantiates 4Ã— fa_1b, no + operator
âœ… alu_4b.v       Instantiates adder_4b + 4Ã— xor_1b
âœ… alu_reg_4b.v   Proper async reset with posedge/negedge
âœ… decoder_fsm.v  Three-block FSM structure
âœ… ram16x4_sync.v Synchronous read/write operations
âœ… simple4_proc.v All components instantiated correctly
```

---

This architecture demonstrates:
- **Bottom-up hierarchical design** (primitives â†’ complex modules)
- **Structural reuse enforcement** (no behavioral shortcuts)
- **Proper RTL synthesis practices** (reset semantics, FSM patterns)
- **Complete processor functionality** (fetch-decode-execute-store cycle)

Perfect for hackathon demonstration! ğŸ¯
